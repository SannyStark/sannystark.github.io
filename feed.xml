<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Блог умелого разработчика</title>
    <description>Блог о програмировании, алгоритмах, уязвимостях, безисходности и черной материи
</description>
    <link>http://sannystark.github.io/</link>
    <atom:link href="http://sannystark.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 05 Jan 2016 16:07:13 +0200</pubDate>
    <lastBuildDate>Tue, 05 Jan 2016 16:07:13 +0200</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Рассеянные програмисты [Перевод]</title>
        <description>&lt;p&gt;Перевод статьи - &lt;a href=&quot;http://theleancoder.net/index.php/2015/11/28/programmers-are-distracted-today/&quot;&gt;Programmers Are Distracted Today&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Если нет желания читать “success story” то прошу сразу к - “примечанию переводчика”
&lt;!--more--&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;
Я бакалавр компьютерных наук и занимаюсь программированием последние два года. Так же у меня есть блог &lt;a href=&quot;http://theleancoder.net&quot;&gt;http://theleancoder.net&lt;/a&gt; в котором я пишу о программированиее и веб-разработке. Ему всего лишь два месяца но он довольно успещен. У меня приблизительно 200 email подписчиков и достойное число посетителей. Так же я пишу статьи для 4-х важных веб-ресурсов о програмировании. Но все было иначе 6 месяцев назад. Первые полтора года не были такими удачными. Виной всему рассейянность ? Я думаю это случается со многими вновь испеченными програмистами. Сегодня я хочу об этом поговорить.&lt;/p&gt;

&lt;p&gt;Когда я написал первую программу “Hello World”, я был безумно рад как и все люди которые становятся на путь программирования. Серьезно, это был самый захватывающий момент. Но у меня не было ни одной идеи что делать дальше. Первая программа была на C и я решил продолжить изучение этого языка. Я одолжил книгу “The C Programming Language” by K&amp;amp;R у друзей и начал ее изучать. Честно выполнял задания после каждой главы, иногда искал помощь в интернете или у друзей. И вот я выучил C, прошло время я познакомился с плюсами, и здесь дорога меня вывела к Java. Каждый раз, когда я брался за изучение нового языка, я получал удовольствие. Я поражался новыми возможностями каждого языка, изучал каждые приемы, я был подобен наркоману, так как не мог без очередной дозы языковых фич. Я был увлечен моментом, но у меня не было цели, я провел в эйфории полтора года но опомнился и сказал что пора остановиться.&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;Открытый рынок&lt;/h3&gt;
&lt;p&gt;Программная индустрия это большое море, и каждый новый программист подобен маленькой рыбке в этих синих просторах. Каждый хочет быть большой рыбкой, но не каждый на это способен. Программисты являются крупнейшими потребителями в Интернете. Мы пользуемся интернетом больше чем обычный средний пользователь. В чем причина ? Потому что интернет кишит изобилием свободных вещей и людей которые готовы тебе помочь. Поэтому не смотря на то что рыбка маленькая, она имеет доступ ко всем закоулкам огромного моря информации. Конечно же есть платный контент и услуги, но они нет так дороги, что бы это было не по силу обычному человеку. И это имеет место быть. Это сравнимо с открытым рынком, где вы показываете ваши возможности и харизму что бы убедить покупателя или пользователя приобрести ту или иную услугу.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;Програмисты жадины&lt;/h3&gt;
&lt;p&gt;Несмотря на то что это открытая площадка, для некоторых новых программистов это является препятствием. Интернет наполнен множеством захватывающих и бесплатных вещей(идей, услуг, информацией) что каждый хочет ухватить кусок по больше. Каждый день создается(изобретается) новый JS framework. Каждый месяц новый инструменты для разработчиков готов быть установленным на ваш компьютер. Каждый год рождается новый язык программирования. И мы программисты очень жадные ко всему новому. И это новое нас очень увлекает. Мы тратим на изучение новых фреймворков определённое время и думаем что это даст нам возможность подняться на новую позицию или место в развивающемся старта-пе. Но внезапно новая технология или фреймворк перестает быть такой актуальной или перестает развиваться, и все что от него остается так это название. Теперь мы хотим изучить что то новое, но не хотим что бы предыдущие усилия были потеряны в пустую. Поэтому мы кидаемся и ищем в интернете статьи подобные : “Изучить &lt;strong&gt;__ за 24 часа” или “Стать ниндзей в __&lt;/strong&gt; за одну неделю”. Но поверьте мне, это не самый лучший пусть что бы что либо изучить, конечно если к вашей голове не приставили пистолет. Изучение программирования никогда не должно следовать этим путем.&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;Какой же путь правильный ?&lt;/h3&gt;
&lt;p&gt;После полуторагодичной траты времени я решил изменить подход. Я решил отказаться от бездумной траты времени и начать делать что то полезное(продуктивное). Что то, что имеет цель и стратегию. Однажды я просидел целый день за просмотром видео на этом канале - &lt;a href=&quot;https://www.youtube.com/channel/UCFxdcuY-S6yjZGq_2cjilHg&quot;&gt;Simple Programmer&lt;/a&gt;. Автор этого видео консультант и программист &lt;a href=&quot;https://twitter.com/jsonmez&quot;&gt;John Sonmez&lt;/a&gt;. Просмотрев его видео я был впечатлен его советами. Я подписался на его курсы по ведению блога, и незамедлительно начал вести свой. Теперь я пишу о том, чему я научился и это придаем мне уверенность в моих знаниях. Я разработал эффективный механизм обучения. Я начал участвовать в open source проектах, а так же завел свой собственный.&lt;/p&gt;

&lt;p&gt;То что я хочу донести, что программирование это не изучение множества языков и фреймворков и не прибывание в мире иллюзий где ты король разработки. Ни кому не важно сколько ты знаешь. Программирование это решение конкретных жизненных проблем, это разделение своего опыта с другими людьми. Все что необходимо, это ставить четкие целы и идти к ним. Я создал блог и я доволен этим. Люди подписываются на мой блог потому что им нравится как я пишу и что я пишу. Если вы хотите стать часть большой софтверной компании работайте над этим. Если вы хотите стать предпринимателем, работайте над идеей на миллион. Если вы хотите быть участником open source проекта - github вам в помощь.&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;Хватит тратить время впустую, ставьте цель и добивайтесь ее!&lt;/h4&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;section-4&quot;&gt;Примечание перводчика&lt;/h4&gt;

&lt;p&gt;Откровенно говоря, оригинал этой статьи был создан для раскрутки блога автора, но все же полезное можно выжать и из этого текста :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Всегда обращайте внимание на то что вы делаете, и анализируйте, приближают ли эти действия(занятия) вас к цели или нет&lt;/li&gt;
  &lt;li&gt;Ставьте цели, начиная с маленьких заканчивая глобальными.&lt;/li&gt;
  &lt;li&gt;Если хотите что то хорошо изучить, попытайтесь обьяснить это другому человеку совсем несмысляшего в этой теме, или заведите блог, что очень помогает в струткурировании знаний у вас в голове.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 05 Jan 2016 12:00:00 +0200</pubDate>
        <link>http://sannystark.github.io/programming/2016/01/05/programmers-are-distructed-today.html</link>
        <guid isPermaLink="true">http://sannystark.github.io/programming/2016/01/05/programmers-are-distructed-today.html</guid>
        
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>Что изменилось в работе HashMap в Java 8?</title>
        <description>&lt;p&gt;Как работает HashMap в Java 7 и как его модифицировали в Java 8.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h4 id=&quot;hashmap&quot;&gt;Как работает HashMap&lt;/h4&gt;

&lt;p&gt;Давайте начнем с простого, как работал(работает) HashMap в Java 7. Map - это структура данных, которая манипулирует (хранит, удаляет, возвращает) key - &amp;gt; value элементы. Иначе, это словарь, который хранит ключ(например слово), и значение(количество слов найденных в определенном тексте). Hash (в контексте HashMap) означает что манипуляция с объектами будет происходить через вычисления hash значений ключа. Но что нам дает простое вычисления ключа ? Другими словами это то же значение ключа, но представлено в другом виде, но не тут то было, каждый объект, в зависимости от hash значения ключа, будет складываться в определённое место - bucket.&lt;/p&gt;

&lt;p&gt;Представьте что при входе в аптеку вы получили талон(с номером 8), и вам необходимо подойти в ту кассу, в которой обслуживает соответствующие набор номеров(5-10) и вы стали в очередь, то есть заняли последнее место. Bucket - в данном случаи это касса с рангом номеров от n до k, а очередь это связанный список.&lt;/p&gt;

&lt;p&gt;Теперь представьте, что входит управляющий аптекой, и пытается найти вас по вашему номеру - 8. Первым делом он находит кассу которая обслуживает именно эти номера, и после по цепочки опрашивает всех, пока не дойдет до вас. Это реализация поиска в HashMap.&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;Проблема&lt;/h4&gt;
&lt;p&gt;По хорошему, каждый bucket должен хранить малое количество объектов, а лучше один, это дает нам константную скорость доступа к объекту - O(1). Но все мы понимаем что без коллизий не обойтись, поэтому один bucket может разрастись до больших размеров. В свою очередь это  приводит к ухудшению времени поиска этого объекта - O(n). Поэтому умные ребята программисты, придумали как это можно побороть.&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;Решение&lt;/h4&gt;
&lt;p&gt;Было принято решение использовать сбалансированное дерево вместо связанного списка - &lt;a href=&quot;http://openjdk.java.net/jeps/180&quot;&gt;JEP&lt;/a&gt;. Но использовать не везде, а лишь когда количество элементов в бакете достигает определенной величины - TREEIFY_THRESHOLD = 8. Такой ход, дает нам более предсказуемое время доступа к обьекту - O(log(n)).&lt;/p&gt;

&lt;p&gt;Это изменение затронуло не всех а лишь : &lt;strong&gt;java.util.HashMap&lt;/strong&gt;, &lt;strong&gt;java.util.LinkedHashMap&lt;/strong&gt; и &lt;strong&gt;java.util.concurrent.ConcurrentHashMap&lt;/strong&gt;.
Например &lt;strong&gt;java.util.HashTable&lt;/strong&gt; - исключили из списка изменений, по причине что в некоторых приложениях как раз таки необходимо сохранять историю заполнения бакета.&lt;/p&gt;

&lt;p&gt;Для тестов можете посмотреть эту &lt;a href=&quot;http://www.nurkiewicz.com/2014/04/hashmap-performance-improvements-in.html&quot;&gt;сылочку&lt;/a&gt;. Исходя из результатов теста, можно привести еще один довод начальнику, для перехода на Java 8.&lt;/p&gt;

&lt;p&gt;Спасибо за внимание.&lt;/p&gt;

</description>
        <pubDate>Fri, 25 Dec 2015 18:00:00 +0200</pubDate>
        <link>http://sannystark.github.io/java/hashmap/2015/12/25/hashmap-java8.html</link>
        <guid isPermaLink="true">http://sannystark.github.io/java/hashmap/2015/12/25/hashmap-java8.html</guid>
        
        
        <category>java</category>
        
        <category>hashmap</category>
        
      </item>
    
      <item>
        <title>Алгоритм работы CMS GC, G1 GC. Часть 2.</title>
        <description>&lt;p&gt;И на закуску, приглашаю на сцену CMS GC, и его усовершенствованного брата G1.
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;В этой статье мы рассмотрим два инкрементальных сборщиков мусора CMS и G1, которые нацелены на уменьшение времени SWT пауз, и увеличить производительность для работы с большими объемами в памяти. Но как мы знаем по треугольнику оптимизации, уменьшая время SWT пауз в данном случае жертвовать придется пропускной способностью. Каждый из сборщиков добивается производительности по разному, давайте посмотрим как.&lt;/p&gt;

&lt;h2 id=&quot;cms-gc&quot;&gt;CMS GC&lt;/h2&gt;

&lt;p&gt;CMS (Concurrent Mark Sweep) - инкрементальный, конкурентный сборщик мусора который появился почти в одно время с Parralell GC. Давайте разберемся, что такое инкрементальный а что такое конкурентный. Инкрементальный означает что сборка мусора, происходит маленькими порциями, во время работы вашего приложения в бэк-граунде, то есть в риал-тайме, в следствии этого, уменьшение STW пауз(к сожалению убрать паузы совсем пока не удалось). И достигается это за счет конкурентных потоков, которые постоянно хотят найти и убрать мусор. Я думаю всем знакомый случай, когда вы сидите за завтраком в закусочной, а к вам постоянно пристает уборщица и просит убрать ноги что бы помыть полы. Подобным образом работает и CMS, вы едите, а вас периодически, и вроде бы не навязчиво, подметают или моют полы.&lt;/p&gt;

&lt;p&gt;Как включить : -XX:+UseConcMarkSweepGC.&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;Принципы работы&lt;/h4&gt;

&lt;p&gt;Начнем с того что мы уже знаем. Этот сборщик мусора использует то же разделение памяти что и предыдущих два - Edem, S-0, S-1, Tunered. Его цель решить проблему долгих пауз. Как правило эти паузы очень хорошо заметны в старшем поколении, так как оно значительно больше по размерам чем младшее, соответственно отслеживание и чистка мертвых объектов по времени больше. Поэтому разработчики пошли путем улучшения именно сборки мусора в старшем поколении.&lt;/p&gt;

&lt;p&gt;В младшем поколении работает все тот же minor цикл, а со старшим поколением работает так называемый major цикл(не путать с полным циклом), который нацелен на оперирование только старшим поколением. К тому же Tunered поколению не обязательно быть до конца заполненным, что бы запустился major цикл, вся работа происходит во время работающего приложения.&lt;/p&gt;

&lt;p&gt;Давайте детально рассмотрим это цикл.&lt;/p&gt;

&lt;p&gt;Начинается все с короткой остановки программы для пометки так называемых корневых объектов. После клиентская программа возобновляется, и параллельно с ней запускается один(несколько) потоков, который индексирует живые объекты используя корневые точки.&lt;/p&gt;

&lt;p&gt;Конечно куча не постоянна, и за время работы программы, некоторые индексы стали не актуальны, поэтому происходит еще одна остановка, для повторного сканирования/индексирования объектов.&lt;/p&gt;

&lt;p&gt;После программа возобновляется и сборщик производит очистку памяти от мертвых объектов в нескольких параллельных потоках. Но есть один нюанс, после очистки объектов из старшего поколения, упаковка(сжатие) происходить не будет, так как это проблематично осуществить во время работающего приложения, поэтому со временем память становиться фрагментированной. В связи с этим GC должен поддерживать особый список с хранением адресов участков свободной памяти (free lists). То есть при создании нового объекта, необходимо обойти этот список, что накладывает дополнительные ресурсы. Поэтом создание объекта дорогостоящая операция данном сборщике мусора.&lt;/p&gt;

&lt;p&gt;Так же это сборщик мусора имеет интеллект и проявляется он в сборке статистики по SWT между major и minor циклами и пытается оптимизировать их во времени (разнести), что бы предотвратить скопление пауз в одном промежутке времени.&lt;/p&gt;

&lt;p&gt;Но что если сборщик мусора не успевать очистить Tunered область, в этом случаи приложение приостанавливается и запускается сборка в последовательном режиме. Такая ситуация называется - concurrent mode failure, то есть сбой конкурентного режима.&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;Плюсы и минусы&lt;/h4&gt;

&lt;p&gt;Как было описано выше, это конкурирующий, инкрементальный сборщик мусора, нацеленный на минимизацию простоя приложения. Для некоторых приложений это является критическим фактором. И так как он работает в фоновом режиме, пропускная способность самого приложения немного падает, так как и приложение, и сборщик мусора, будут конкурировать за ресурсы. Так же отсутствие уплотнения(сжатия) фрагментирует память, что заставляет нас выделять больше памяти (20-30 %) для этого.&lt;/p&gt;

&lt;p&gt;Но такой сборщик может подойти приложениям, использующим большой объем долгоживущих данных. В этом случае некоторые его недостатки опускаются.&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;Настройка&lt;/h4&gt;

&lt;p&gt;Те же настроки что и в Parralell GC.&lt;/p&gt;

&lt;p&gt;-XX:CMSInitiatingOccupancyFraction=? - пороговое значение наполения Tunered области, для запуска цикла полной сборки мусора&lt;/p&gt;

&lt;h2 id=&quot;g1-gc&quot;&gt;G1 GC&lt;/h2&gt;

&lt;p&gt;G1 (Garbage First) - один из молодых(последних) сборщиков мусора. Он не является наследником предыдущих GC, он не добавляет еще параллельности или конкурентности, он не разбивает на еще большее количество областей память, он кардинально меняет подход к самой сборке.&lt;/p&gt;

&lt;p&gt;Это самый первый конкурент CMS GC, который позиционирует себя как сборщик мусора для работы с большими кучами ( &amp;gt; 4Гб) для которого важна сохранность времени отклика и предсказуемость. Компания Oralce хочет выдвинуть его как стоящую замену CMS и поставить его стандартным сборщиком мусора для серверных конфигурация в 9-й версии.&lt;/p&gt;

&lt;p&gt;Как включить : -XX:+UseG1GC&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;Принципы работы&lt;/h4&gt;

&lt;p&gt;Первое что бросается к глаза, так это организация кучи. Здесь память разбивается на множество участков от 1-32 Мб, и каждый из этих участков можеть быть как и Edem, S-0, S-1 так и Tunered. Исключением лишь являются громадные участки (humongous), которые создаются объединением простых регионов.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/G1.png&quot; alt=&quot;pic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Малые сборки работаю с младшими поколениями, и выполняются они периодически, все так же для переноса выживших из Edem в S-0, S-1 или Tunered. Никуда нам не деться от SWT пауз, которые присутствуют и здесь, но есть кардинальное отличие, сборщик мусора сам решает над каким из младших поколений ему работать, исходя из заданного времени и максимально выгодного результата. Поэтому его и прозвали Garbage First - то есть - мусор превыше всего.&lt;/p&gt;

&lt;p&gt;Работа со старшим поколением называется смешанным циклом, и она так же отличается от CMS маленькой особенностью. В G1 существует процесс, называемый циклом пометки (marking cycle), который работает параллельно с основным приложением и составляет список живых объектов. Подобный процесс присутствует и в CMS, но немного отличается в конце.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Маркировка корневых объектов полученных из малых циклов (Initial mark), остановка приложения&lt;/li&gt;
  &lt;li&gt;Параллельная пометка живых объектов (Concurrent marking), во время работающего приложения&lt;/li&gt;
  &lt;li&gt;Остановка приложения и повторный поиск неучтенных объектов (Remark)&lt;/li&gt;
  &lt;li&gt;Очистка от мусора при остановленном приложении, поиск пустых регионов для новых объектов параллельно с работающим приложением&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;После G1 переключается в режим смешанной сборки. Это означает, что к младшим регионам, подлежащим очистке, подселяют некоторое количество из старшего региона. Делается это для того что бы оптимизировать и уложится в заданное время сборки, а размеры подселяемых участков и их количество коррелируется статистикой собранной на предыдущих циклах. После того как GC собрал достаточно мусора, он переключается в режим малой сборки.&lt;/p&gt;

&lt;p&gt;Может произойти ситуация, что в процессе очисти не останется памяти для винивших объектов, в таком случаи запускается полный сборщик мусора и приложение приостанавливается.&lt;/p&gt;

&lt;p&gt;Следует упомянуть о гигантских объектах (humongous objects) - те которые не помещаются в один регион. Обработка этих объектов следует таким правилам : 
 - такой объект никогда не копируется/перемещается между регионами
 - он может быть удален как во время цикла маркировки, так и во время цикла очистки
 - к таким регионам никогда никого не подселяют&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;Плюсы и минусы&lt;/h4&gt;

&lt;p&gt;Цель этого сборщика мусора сделать эти сборки настолько предсказуемыми насколько возможно. Так же он решает проблему фрагментации памяти. Конечно же что бы всего этого достичь, необходимо жертвовать пропускной способность(нагрузкой на CPU). На данном этапе я думаю это достойная замена CMS для северных приложений, а так же как плацдарм для экспериментов.&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;Настройка&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;-XX:ParallelGCThreads=? - количество потоков для сборки мусора&lt;/li&gt;
  &lt;li&gt;-XX:ConcGCThreads=? - количество потоков для цикла пометок&lt;/li&gt;
  &lt;li&gt;-XX:G1HeapRegionSize=? - размер области региона&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Вот мы и познакомились со всеми сборщиками мусора в виртуальной машине HotSpot. Надеюсь эти статьи пролили свет на многие аспекты работы GC а так же добавило понимая, что же там все таки твориться под капотом.&lt;/p&gt;

&lt;p&gt;В следующей статье я расскажу, какие есть проблемы у JVM (OutOFMemory etc), как их можно решать, и какие есть способы трекинга и оптимизации JVM.&lt;/p&gt;
</description>
        <pubDate>Wed, 23 Dec 2015 18:00:00 +0200</pubDate>
        <link>http://sannystark.github.io/java/jvm/gc/2015/12/23/gc-jvm-part3.html</link>
        <guid isPermaLink="true">http://sannystark.github.io/java/jvm/gc/2015/12/23/gc-jvm-part3.html</guid>
        
        
        <category>java</category>
        
        <category>jvm</category>
        
        <category>gc</category>
        
      </item>
    
      <item>
        <title>Алгоритм работы Serial GC, Parrallel GC. Часть 1.</title>
        <description>&lt;p&gt;Рассмотрим двух ветеранов по сборке мусора в HotSpot JVM и их особенности.
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;gc----&quot;&gt;Как GC очищает память от мусора&lt;/h2&gt;
&lt;p&gt;Есть несколько алгоритмов очищения мусора, из основных можно выделить два :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Copying collectors&lt;/li&gt;
  &lt;li&gt;Mark-sweep-compact&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;copying-collectors&quot;&gt;Copying collectors&lt;/h4&gt;

&lt;p&gt;Память делится на два участка : from-space и to-space.&lt;/p&gt;

&lt;p&gt;Принцип работы таков :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Создание(allocate) объекта в “from-space” (1,2)&lt;/li&gt;
  &lt;li&gt;Когда “from-space” заполнен, запускатеся сборщик мусора (3)&lt;/li&gt;
  &lt;li&gt;Приложение приостанавливается (stop-the-world)&lt;/li&gt;
  &lt;li&gt;Находятся живые объекты в “from-space” и копируются в “to-space” (4)&lt;/li&gt;
  &lt;li&gt;Когда все объекты скопированы в “to-space”, “from-space” полностью очищается (5)&lt;/li&gt;
  &lt;li&gt;После “to-space” и “from-space” меняются местами (5)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://www.artima.com/insidejvm/ed2/images/fig9-1.gif&quot; alt=&quot;JVM Memory Model&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Минусы подхода:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;From-space и to-space должны быть одинакового размера&lt;/li&gt;
  &lt;li&gt;Приложение должно остановиться пока полностью не скопирует живые объекты в новую область памяти&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;mark-sweep-compact&quot;&gt;Mark-sweep-compact&lt;/h4&gt;

&lt;p&gt;Процесс работы можно описать так:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Создание(allocate) обьекта в памяти (1)&lt;/li&gt;
  &lt;li&gt;Запустить GC&lt;/li&gt;
  &lt;li&gt;Приложение приостанавливается (stop-the-world)&lt;/li&gt;
  &lt;li&gt;Обход дерева для маркировки мертвых обьектов (2)&lt;/li&gt;
  &lt;li&gt;Удаление объектов из памяти (3)&lt;/li&gt;
  &lt;li&gt;После происходит дефрагментация памяти, то есть сжатие(перенесения) живых объектов в начало (4)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://adamansky.bitbucket.org/slides/gc/img/msc2.png&quot; alt=&quot;JVM Memory Model&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Минусы:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Приложение останавливается пока происходит сборка мусора&lt;/li&gt;
  &lt;li&gt;Время работы зависит от размеров памяти и количества объектов&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Сборщики мусора HotSpot VM используют подход “Generational Garbage Collection”. Такой подход позволяет использовать разные алгоритмы для разных этапов(областей памяти) сборки мусора что добавляет эффективности в его работе.&lt;/p&gt;

&lt;p&gt;Как я писал в &lt;a href=&quot;/java/jvm/gc/2015/12/23/gc-jvm-begin.html&quot;&gt;первой&lt;/a&gt; статье, опытным путем было замечено что большинство новых объектов быстро становятся мусором, и что количество связей между выжившими объектами и вновь родившимися сводятся к минимуму. Была выдвинута слабая гипотеза(weak generational hypothesis) на которую и опирается “Generational Garbage Collection”.&lt;/p&gt;

&lt;h2 id=&quot;serial-gc&quot;&gt;Serial GC&lt;/h2&gt;

&lt;p&gt;Serial GC - (последовательный сборщик мусора) это один из первых сборщиков мусора который анонсировала компания Oracle с 1.3 версией Java.
Он медленно но уверенно работал в те далекие времена, когда только начинали съемки фильма первой части трилогии “Матрица” и апплеты считалось нормой для web-приложений.&lt;/p&gt;

&lt;p&gt;Он очень хорошо проявляет себя в работе с небольшим объемом памяти (100-200 Mb) и в одно-процессорной среде.&lt;/p&gt;

&lt;p&gt;Как включить : -XX:+UseSerialGC.&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;Принцип работы&lt;/h4&gt;

&lt;p&gt;Принцип сборки мусора основывается на поколениях, и к каждому участку памяти применяется свой алгоритм сборки.&lt;/p&gt;

&lt;p&gt;Память разделяется на младшее(Edem, Survivor 0,1) и старшее поколения(Tenured)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/serial-gc-1.png&quot; alt=&quot;pic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Выделяются два этапа сборки мусора :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;minor GC&lt;/li&gt;
  &lt;li&gt;major GC (полная)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Новые объекты рождаются в Edem.
В определенный момент запускается минорный сборщик мусора который копирует выжавшие объекты в S-0&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/serial-gc-2.png&quot; alt=&quot;pic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/serial-gc-3.png&quot; alt=&quot;pic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;После очередной сборки мусора, выжившие объекты копируются из Edem и S-0 в S-1, соответственно S-0 становится доступен для выживших объектов.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/serial-gc-4.png&quot; alt=&quot;pic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Другими словами в минорной сборке мусора работает алгоритм “Copying collectors”.&lt;/p&gt;

&lt;p&gt;Так же сборщик мусора следит за тем, сколько циклов сборки мусора пережил объект, для того что бы он стал достаточно стар, что бы попасть в Tenured.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/serial-gc-5.png&quot; alt=&quot;pic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;После того как Tenured заполнился до определенной критической точки, на ринг выходит major GC, который стирает грань между поколениями(если быть точным то работает с двумя поколениями) и чистит всю память используя алгоритм “Mark-sweep-compact” для старого поколения и “Copying collectors” для молодого.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/serial-gc-6.png&quot; alt=&quot;pic&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;Плюсы и минусы&lt;/h4&gt;

&lt;p&gt;Это одно-поточный сборщик мусора, который очень любит stop-the-world(STW) моменты. И работает он с небольшим объемом памяти, так как при увеличении (памяти), STW паузы будут более заметны. Можно сделать вывод что он не прихотлив к ресурсам и спокойно себе пашет в полях операционной среды. Если у вас слабенькая(старенькая) машинка, и не критичны STW паузы, то этот сборщик мусора будет вам очень кстати.&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;Настройка&lt;/h4&gt;

&lt;p&gt;Единственное с чем можно поиграться в настройках так это с регулировкой объемов поколений и значением процента заполнения поколений, когда будет срабатывать GC.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Xms и Xmx можно настроить начальный и максимально допустимый размер кучи.&lt;/li&gt;
  &lt;li&gt;-XX:MinHeapFreeRatio=? и -XX:MaxHeapFreeRatio=? задают минимальную и максимальную долю свободного места в каждом поколении, при достижении которой размер поколения будет автоматически увеличен или уменьшен соответственно.&lt;/li&gt;
  &lt;li&gt;-XX:NewRatio=? отношение размера старшего поколения к суммарному размеру регионов младшего поколения&lt;/li&gt;
  &lt;li&gt;-XX:-UseGCOverheadLimit - порог активности сборщика мусора при котором он будет срабатывать&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;parralell-gc&quot;&gt;Parralell GC&lt;/h2&gt;
&lt;p&gt;Parallel GC (параллельный сборщик) - перенимает идеи Serial GC добавляя в них параллелизм и немного интеллекта. JVM  может автоматически задействовать его если на вашем компьютере несколько ядер.&lt;/p&gt;

&lt;p&gt;Как включить : -XX:+UseParallelGC.&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;Принцип работы&lt;/h4&gt;

&lt;p&gt;При включении параллельного сборщика мусора используются те же самые подходы что и в GC, та же разбивка памяти на Edem, S-0, S-1, Tunered, те же алгоритмы сборки minor cycle и major cycle, но во первых сборка мусора происходит в параллельном режиме, во вторых, добавляется “интеллектуальность” для оптимизации производительности о которой мы поговорим ниже.&lt;/p&gt;

&lt;p&gt;Для параллельной обработки объектов, действует немного изменённый механизм переноса. Так например каждый поток GC получает свой участок памяти куда он будет копировать выжившие объекты что бы не мешать другим потокам. Это дает ускорение, но немного дефрагментирует память.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/parallel-gc-1.png&quot; alt=&quot;pic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Интеллектуальной составляющей как раз является то, что производительность сборки мусора(так и самого приложения) можно настраивать так, что бы она удовлетворяла ваши потребности. Вы можете указать устраивающие вас параметры производительности — максимальное время сборки и/или пропускную способность — и сборщик будет изо всех сил стараться не превышать заданные пороги. Для этого он будет использовать статистику уже прошедших сборок мусора и исходя из нее планировать параметры дальнейших сборок: варьировать размеры поколений, менять пропорции регионов.&lt;/p&gt;

&lt;p&gt;Но это не значет, что GC запрещает нам корректировать размеры поколений самостоятельно, но не рекомендуется это делать одновременно (что бы портить внутреннюю статистику).&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;Плюсы и минусы&lt;/h4&gt;

&lt;p&gt;Время STW пауз значительно ниже, так как сборка происходит в параллельном режиме, да и плюс “интеллектуальность” помогает еще больше уменьшить эти паузы (предварительно разогрев JVM). Из минусов можно сказать что появляется фрагментация памяти, но вряд ли она будет значительной, так как сборщиком мусора использует относительно небольшое количество потоков.&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;Настройка&lt;/h4&gt;

&lt;p&gt;Размер областей поколений настраивается так же как и Serail GC, поэтому здесь мы рассмотрим настройку производительности для нашего “умного” сборщика мусора.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-XX:ParallelGCThreads=? - количество потоков для сборки мусора&lt;/li&gt;
  &lt;li&gt;-XX:-UseParallelOldGC. - так же можно исключить работу параллельного сборщика мусора в старшем поколении, задействовав однопоточный&lt;/li&gt;
  &lt;li&gt;-XX:MaxGCPauseMillis - устанавливает ограничение на максимальное время приостановки программы для сборки мусора&lt;/li&gt;
  &lt;li&gt;GCTimeRatio - можно указать желаемый порог пропускной способности (отношения времени работы программы ко времени сборки мусора)&lt;/li&gt;
  &lt;li&gt;-XX:YoungGenerationSizeIncrement=? и -XX:TenuredGenerationSizeIncrement=? устанавливают, на сколько процентов следует при необходимости увеличивать младшее и старшее поколение соответственно. По умолчанию оба этих параметра равны 20.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В целом эти два сборщика мусора являются основополагающими и подходят для большинства приложений. Они просты, понятны, без лишних овехэдов и скрытых накладных ресурсов.&lt;/p&gt;

&lt;p&gt;В следующей статье мы коснемся более изощренных подходов и механизмов в сборке мусора, таких как CMS GC и G1.&lt;/p&gt;
</description>
        <pubDate>Wed, 23 Dec 2015 18:00:00 +0200</pubDate>
        <link>http://sannystark.github.io/java/jvm/gc/2015/12/23/gc-jvm-part2.html</link>
        <guid isPermaLink="true">http://sannystark.github.io/java/jvm/gc/2015/12/23/gc-jvm-part2.html</guid>
        
        
        <category>java</category>
        
        <category>jvm</category>
        
        <category>gc</category>
        
      </item>
    
      <item>
        <title>Что такое GC в JVM? алгоритмы работы. Введение.</title>
        <description>&lt;p&gt;Сегодня я хочу окунуться в мир сборщика мусора, и рассказать вам о том зачем он нужен? какие алгоритмы используются в JVM для сборки мусора? Как развивались эти алгоритмы от версии к версии и что нас ждет впереди.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Эта тема будет расскрыта в нескольких постах :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Введение - что такое сборщик мусора, зачем он нужен и как он понимает что этот объект необходимо удалить из памяти&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/java/jvm/gc/2015/12/23/gc-jvm-part2.html&quot;&gt;Алгоритм работы Serial GC, Parrallel GC&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/java/jvm/gc/2015/12/23/gc-jvm-part3.html&quot;&gt;Алгоритм работы CMS GC и G1 GC.&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;#&quot;&gt;Принцип Паретто и способы оптимизации&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gc-&quot;&gt;Что такое GC ?&lt;/h2&gt;
&lt;p&gt;Если спросить любого технического человека что такое сборка мусора, то он ответит “сбор мусора - это когда операционная среда автоматически освобождает память, которая больше не используется программой. Она делает это путем трассировки памяти, начиная от корня, чтобы определить, какие объекты ещё доступны”[1].&lt;/p&gt;

&lt;p&gt;В этом описании перепутаны местами механизм с целью. Это всё равно что сказать, что работа пожарного - “водить красную машину и брызгаться водой”. Это описание того, что делает пожарный, но здесь не указана цель этой деятельности (а именно: тушить огонь, а в общем случае: пожарная безопасность)[1].&lt;/p&gt;

&lt;p&gt;Сборка мусора - это эмуляция компьютера с бесконечной памятью. А все остальное это механизмы.  “Сбор памяти, которую программа уже не видит” - это один из механизмов.  Механизм сборки мусора присутствует во многих современных виртуальных машинах таких как : V8(Javascript), JVM(Java), Parrot(Python), Ruby(YARV) и т.д.&lt;/p&gt;

&lt;p&gt;Основной принцип GC это с одной стороны, упростить программирование, избавив программиста от необходимости вручную удалять объекты, созданные в динамической памяти, с другой — устранить ошибки, вызванные неправильным ручным управлением памятью. В основном модуль сборщика мусора включается в состав среды исполнения и запускается в прозрачном для пользователя режиме.&lt;/p&gt;

&lt;h2 id=&quot;jvm--&quot;&gt;Как разделена памяти в JVM, теория поколений&lt;/h2&gt;

&lt;p&gt;Память, которая использует JVM, грубо можно разделить на две части : HEAP и (non-heap)STACK.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;HEAP (куча) - отвечает за рождения и хранения объектов, то есть всех наследников класса Object.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;STACK - область памяти которая хранит мета информацию о классах(методах), значения примитивных типов, локальные значения потоков и …&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В свою очередь каждый участок памяти делиться на более детальные кусочки, которые можно проследить на этом рисунке :
&lt;img src=&quot;http://www.pointsoftware.ch/wp-content/uploads/2012/10/JUtH_20121024_RuntimeDataAreas_6_MemoryModel.png&quot; alt=&quot;JVM Memory Model&quot; /&gt;&lt;/p&gt;

&lt;p&gt;В свою очередь поступает вопрос, зачем нам разделять и разделять память если можно все хранить в одном месте. Есть такая гипотеза(слабая гипотеза), говорящая о том, что большинство новых объектов живут очень не долго, а чем дольше прожил объект, тем выше вероятность того, что он будет жить и дальше. Поэтому разработчиков GC это навело на мысль что в первую очередь необходимо сосредотачиваться на очистке тех объектов, которые были созданы совсем недавно. Именно среди них чаще всего находится бóльшее число тех, кто выжил, и именно здесь можно получить максимум эффекта при минимуме трудозатрат.&lt;/p&gt;

&lt;p&gt;Здесь и родилась идея о том что бы разделить память на разные участки : младшее поколение (young generation) и старшее поколение (old generation) и применять к разным участкам памяти разные алгоритмы сборки мусора.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;Алгоритмы поиска мертвых объектов&lt;/h2&gt;

&lt;p&gt;Что бы GC начал свою работу необходимо намусорить, чтобы объект стал доступен для сборки мусора. Доступные объекты в Java это объекты которые не имеют сильных ссылок. В Java для этого мы или присваиваем ссылке null :&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// обьект на который ссылалась ссылка ref теперь доступен сборщику мусора&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;или обьект выходит из своей области видимости :&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ошибка компиляции&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// обьект на который ссылается ref теперь доступен сборщику мусора, &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// потому при выходе программы из фигурных скобок &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// обьект становиться недосутпен в дальнейшем коде, поэтому его можно удалить&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;section-1&quot;&gt;Существует два алгоритма для обнаружения мусора:&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Reference counting&lt;/li&gt;
  &lt;li&gt;Tracing&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;reference-counting&quot;&gt;Reference counting&lt;/h4&gt;

&lt;p&gt;Суть подхода заключается в подсчете ссылок. Счетчик хранит сколько ссылок на него указывают и уменьшает свое значение когда ссылка уничтожается, то есть перестает ссылаться на объект.&lt;/p&gt;

&lt;p&gt;Главным минусом такого подхода является сложность обеспечение счетчика в многопточной среде, а так же полное отсуствие выявления цыклических связей (когда первый обьект ссылается на второй, а второй ссылается на первый). Такой подход приводит к утечкам памяти что не есть хорошо, поэтому отложим его.&lt;/p&gt;

&lt;h4 id=&quot;tracing&quot;&gt;Tracing&lt;/h4&gt;

&lt;p&gt;Главная идея “Tracing” состоит в том, что живые объекты это те, к которым мы можем добраться из корневых точек, а все остальное мусор.
Объекты можно представить как дерево, и нам остается лишь пройтись по дереву (начиная с корневых элементов) и обозначить живых объектов. А не маркированные объекты соответственно будут являться мусором.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://plumbr.eu/wp-content/uploads/2015/05/Java-GC-mark-and-sweep.png&quot; alt=&quot;JVM Memory Model&quot; /&gt;&lt;/p&gt;

&lt;p&gt;HotSpot использует именно такой подход. 
Но что такое корневые точки ? :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Локальные переменные и параметры методов&lt;/li&gt;
  &lt;li&gt;Статические переменные (метод main)&lt;/li&gt;
  &lt;li&gt;Java Потоки&lt;/li&gt;
  &lt;li&gt;Ссылки из JNI&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;Треугольник оптимизации&lt;/h2&gt;

&lt;p&gt;При определении эффективности работы сборщика мусора можно выделить три фактора:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Максимальная задержка (Latency) — максимальное время, на которое сборщик приостанавливает выполнение программы для выполнения одной сборки. Такие остановки называются stop-the-world.&lt;/li&gt;
  &lt;li&gt;Пропускная способность (Throughput) — отношение общего времени работы программы к общему времени простоя, вызванного сборкой мусора, на длительном промежутке времени.&lt;/li&gt;
  &lt;li&gt;Потребляемые ресурсы (Footprint) — объем ресурсов процессора и памяти, потребляемых сборщиком.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;На рисунке факторы представлены в виде треугольника :&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/jvm-perfomnce-triangle.png&quot; alt=&quot;JVM Memory Model&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Интересней всего то, что мы можем улучшить только две вершины этого треугольника, то есть потянуть за два угла в ущерб третьему. Например уменьшая потребляемые ресурсы и увеличивая пропускную способность нам необходимо жертвовать временем максимальной задержки что в нашем случаи вырастет.&lt;/p&gt;

&lt;p&gt;На данный момент мы знаем что такое мертвые объекты и как их сделать таковыми, а так же знаем как GC их распознает. В следующей статье мы познакомимся с алгоритмами удаления объектов из памяти и как работают разные версии сборщиков мусора.&lt;/p&gt;

&lt;p&gt;[1] - http://www.transl-gunsmoker.ru/2012/09/blog-post.html&lt;/p&gt;
</description>
        <pubDate>Wed, 23 Dec 2015 12:00:00 +0200</pubDate>
        <link>http://sannystark.github.io/java/jvm/gc/2015/12/23/gc-jvm-begin.html</link>
        <guid isPermaLink="true">http://sannystark.github.io/java/jvm/gc/2015/12/23/gc-jvm-begin.html</guid>
        
        
        <category>java</category>
        
        <category>jvm</category>
        
        <category>gc</category>
        
      </item>
    
      <item>
        <title>Пару дефектов(багов) в JSF 2.0 - 2.1.18</title>
        <description>&lt;p&gt;После очередного сканирования сервиса на проникновения, наткнулся на очень инетрессную уязвимость в JSF 2.1 связанную с доступом к ресурсам через http без авторизации.&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;&lt;img src=&quot;http://www.onstagetechnologies.com/wp-content/uploads/2012/02/bug.jpg&quot; alt=&quot;enter image description here&quot; /&gt;&lt;/p&gt;

&lt;p&gt;JSF2 - MVC web-фреймворк позволяющий с легкостью создавать простые(сложные) web-ориентированные приложения за меньшее количество времени и усилий. Другим словами это набор интерфейсов и спецификаций:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;JSF 2.1 - JSR 314&lt;/li&gt;
  &lt;li&gt;JSF 2.2 - JSR 344&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Mojarra&lt;/strong&gt; - это оракловская имплементация этих стандартов.
Её(mojarra) поддерживают такие сервера как :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Glassfish&lt;/li&gt;
  &lt;li&gt;JBoss&lt;/li&gt;
  &lt;li&gt;WebLogic&lt;/li&gt;
  &lt;li&gt;Apache Tomcat&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Наши злобные дефекты содержатся как раз в имплементации JSF 2.0 - 2.1.18 (JSR 314) версий.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;resource-identifier&quot;&gt;Дефект 1: Обходной путь через Resource Identifier&lt;/h3&gt;

&lt;p&gt;Один из дефектов связанный с обработкой идентификатора ресурсов(resource identifier). Mojarra не проверяет имя ресурса начинающегося ../ таким разделителем. Конечно это дефект ограничен, мы не можем попаcть в корень нашего приложения или файловой системы сервера, но можем спокойно гулять по папке WEB-INF.
&lt;code class=&quot;highlighter-rouge&quot;&gt;
http://www.example.com/someApp/javax.faces.resource.../WEB-INF/web.xml.jsf
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;library-name&quot;&gt;Дефект 2: Обходной путь через Library Name&lt;/h3&gt;

&lt;p&gt;Второй способ связан с обработкой имени библиотеки. Mojarra не проверяет имена библиотек с разделителем .. . Дефект так же ограничен как и первый по свободе доступа.
&lt;code class=&quot;highlighter-rouge&quot;&gt;
http://www.example.com/someApp/javax.faces.resource./WEB-INF/web.xml.jsf?ln=..
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;Пути решения&lt;/h3&gt;

&lt;p&gt;Первый, и самый простой, запретить обработчику ресурсов отдавать файлы с определёнными суффиксами расширения. По умолчанию у обработчика ресурсов уже есть ряд исключительных суффиксов.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ResourceHandler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lang&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RESOURCE_EXCLUDES_DEFAULT_VALUE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;.class .jsp .jspx .properties .xhtml .groovy&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Мы лишь расширим этот список в файле дескриптора web приложения :&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;context-param&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;param-name&amp;gt;&lt;/span&gt;javax.faces.RESOURCE_EXCLUDES&lt;span class=&quot;nt&quot;&gt;&amp;lt;/param-name&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;param-value&amp;gt;&lt;/span&gt;
        .class .jsp .jspx .properties .xhtml .groovy .jsf .xml
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/param-value&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/context-param&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Ну а второй способ, обновиться до более новой версии 2.1.19&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;Ресурсы :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://mvnrepository.com/artifact/com.sun.faces/jsf-impl&quot;&gt;http://mvnrepository.com/artifact/com.sun.faces/jsf-impl&lt;/a&gt; - версии jsf имплементаций для скачивания.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2013-3827&quot;&gt;https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2013-3827&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 01 Mar 2014 13:00:42 +0200</pubDate>
        <link>http://sannystark.github.io/java/jsf/2014/03/01/bug-jsf2-1.html</link>
        <guid isPermaLink="true">http://sannystark.github.io/java/jsf/2014/03/01/bug-jsf2-1.html</guid>
        
        
        <category>java</category>
        
        <category>jsf</category>
        
      </item>
    
      <item>
        <title>Java script best practies for beginner</title>
        <description>&lt;p&gt;6 советов начинающему Javascript девелоперу.
&lt;!--more--&gt;&lt;/p&gt;

&lt;h4 id=&quot;javascript-----&quot;&gt;1. JavaScript не поддерживает ассоциативные массивы(хештаблицы, мапы).&lt;/h4&gt;

&lt;p&gt;Для этого можно использовать объекты :&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;apple&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;strawberry&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;обращаться к ним можно так :&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;  &lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;apple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 6&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;strawberry&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 50&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Удаление свойств лучше сделать через метод delete -&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;apple&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Object {strawberry: 50}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;таким способом удалиться сама запись из объекта.
В противном случаи можно было сделать так :&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;  &lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;apple&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// или&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;apple&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// но ключ самого элемента в объекте всё равно останется&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Object {apple: undefined, strawberry: 50}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Разница между строковой нотацией&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;apple&#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;strawberry&#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;и&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;apple&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;strawberry&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;в том,что в первом случае, объект map можно использовать как JSON объект.&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;2. Используйте &lt;strong&gt;===&lt;/strong&gt; вместо ==&lt;/h4&gt;
&lt;p&gt;Проблема == в том, что этот оператор автоматически преобразовывает типы во время сравнения. Поэтому == и === дают разные результаты :&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&#39;10&#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;s1&quot;&gt;&#39;10&#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// false&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;section-1&quot;&gt;3. Избегайте глобальных переменных&lt;/h4&gt;
&lt;p&gt;Создание любой переменной, без идентификатора var автоматически делает эту переменную глобальной. Что приводит конфликту имен во время работы с посторонним кодом.
JS не поддерживает блочную область видимости.
Код :&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 5&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;и&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 5&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;идентичен.&lt;/p&gt;

&lt;p&gt;Для таких случаев в JS есть функциональная область видимости.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// переменная видна только внутри функции&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ReferenceError: a is not defined&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;section-2&quot;&gt;4. Сокрытие функций от глобальной области видимости&lt;/h4&gt;
&lt;p&gt;При написании какой нибудь своей утилиты или либы, желательно скрыть весь её функционал в какой нибудь одной переменной. Это даст вам бесконфликтное внедрение и хорошие условия сосуществования с другим сторонним js-ом.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;nx&quot;&gt;MyUtil&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;calculate&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;sayHello&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hello &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;MyUtil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;calculate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 17&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;MyUtil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sayHello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;World&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;Hello World&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Так же можно скрывать не только функции но и переменные, только немного другим способом.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;MyUtil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// эта переменная является приватной&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;increment&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;clear&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
            &lt;span class=&quot;nx&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Переменная counter не видна никому, кроме внутренних функций.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;MyUtil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; 
&lt;span class=&quot;c1&quot;&gt;// var foo = new MyUtil(); другой вариант инициализации&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// будет ошибка&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Использовать MyUtil можно таким способом :&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;MyUtil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;increment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;increment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Отличие первого способа от второго, в том, что в первом уже происходит инициализация объекта, а во втором можно сказать, только описание, а инициализация во время присваивания.
Если сравнивать с языком Java, то первый случай, это статические свойства и методы, а второй, полноценный класс, который необходимо проинициализировать, прежде чем использовать.&lt;/p&gt;

&lt;h4 id=&quot;dom&quot;&gt;5. Альтернативная конкатенация строк и работа с DOM&lt;/h4&gt;
&lt;p&gt;Допустим необходимо создать список каких нибудь элементов и добавить эти элементы в HTML код.
Первый способ который приходит в голову :&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;item1&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;item2&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;item3&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;lenght&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;some_id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerHtml&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;div class=&#39;class&#39;&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;/div&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;В коде есть по крайне мере два проблемных места.
Первое. Обращение в элементам DOM модели очень затратный процесс. Поэтому избавимся от него и будем делать это единожды.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;item1&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;item2&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;item3&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;htmlList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;lenght&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;htmlList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;div class=&#39;class&#39;&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;/div&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;some_id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerHtml&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;htmlList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Второе. Конкатенация строк может работать быстрее.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;item1&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;item2&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;item3&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;htmlList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;div class=&#39;class&#39;&amp;gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;/div&amp;gt;&amp;lt;div class=&#39;class&#39;&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;/div&amp;gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;some_id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerHtml&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;htmlList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;blockquote&gt;
  &lt;p&gt;I won’t bore you with benchmarks; you’ll just have to believe me (or test for yourself) - this is by far the fastest method!
Using native methods (like join()), regardless of what’s going on behind the abstraction layer, is usually much faster than any non-native alternative.
- James Padolsey, james.padolsey.com&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;self-executiong-function&quot;&gt;6. Self-Executiong Function&lt;/h4&gt;

&lt;p&gt;Это функция, которая выполняется автоматически при её создании, и имеет следующий вид:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;c1&quot;&gt;// 30&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;hr /&gt;
&lt;p&gt;Ну и для тех, кому не хватило, вот пару ссылок на полезные ресурсы :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://shamansir.github.io/JavaScript-Garden/&quot;&gt;JavaScript Гарден&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://flippinawesome.org/2013/12/23/45-useful-javascript-tips-tricks-and-best-practices/&quot;&gt;KEEP CALM and LEARN JavaScript&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://habrahabr.ru/post/175283/&quot;&gt;24 совета javascript-разработчику&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 01 Mar 2014 12:00:42 +0200</pubDate>
        <link>http://sannystark.github.io/javascript/2014/03/01/javascript-best-practies.html</link>
        <guid isPermaLink="true">http://sannystark.github.io/javascript/2014/03/01/javascript-best-practies.html</guid>
        
        
        <category>javascript</category>
        
      </item>
    
      <item>
        <title>SynchronizedMap, ConcurrentHashMap и многопоточность</title>
        <description>&lt;p&gt;В сегодняшнем посте, я хочу рассказать как работают synchronizeHashMap и ConcurrentHashMap. Как они ведут себя в &lt;strong&gt;многопоточный&lt;/strong&gt; среде и в чём их главное отличие.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Начнём из далека. Что такое &lt;strong&gt;HashMap&lt;/strong&gt; - это key/value хранилище с особой структурой хранения данных. Ключевое слово здесь Hash(Hashing). Hashing - это процесс вычисления hash-функции ключа записываемого значения. Именно по этому параметру, значение кладется в определённой место в hashTable называемое hash bucket.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://anbuwrites.files.wordpress.com/2010/09/image003.jpg&quot; alt=&quot;enter image description here&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Слева от 0 до 6, это так называемые hash buckets. Допустим, мы хотим добавить значение в нашу HashMap - put(‘PIG’,29). Первое что происходит, это вычисление hash по ключу. После это значение пропускатеся через фильтр (остаток от деления по модулю 6 в данном примере). Это необходимо для нахождения определённого hash bucket-а(3). Ключ и значение преобразуются в определённую структуру (Entry).&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Entry&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Entry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Entry&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//More code goes here&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;И добавляются в коллекцию, подобную LinkedList.&lt;/p&gt;

&lt;p&gt;По простому HashMap - это массив hash-bucket-ов, которые хранят в себе данные в структуре связанного списка.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Synchronized Map&lt;/strong&gt; - это потокобезопасная коллекция данных основанная на взаимоблокировках. Что это нам говорит? Все методы, связанные с добавлением/удалением данных, синхронизированы, и для получения значения из одного потока нам необходимо ждать, пока другой поток завершит работу с Map-ой. Разновидностью синхронизированной мапы является HashTable (JDK 1.0).&lt;/p&gt;

&lt;p&gt;Для небольшого количества потоков, или где необходимо обезопасить свои данные в конкуретной среде потоков, это работает более менее приемлемо. Но когда необходимо использовать Map в хаотическом мире многопоточного программирования, на сцену выходит ConcurrentHashMap.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ConcurrentHashMap&lt;/strong&gt; - это тот же HashMap, но рассчитан для работы в многопоточной среде. Главным отличием является то, что ему не нужно иметь синхронизированные блоки данных для доступа или записи информации. То есть ему ненужно блокировать самого себя для других потоков. Но как же тогда он корректно работает в многопоточной среде ? и какие требования выдвигались со стороны разработчиков?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Потокобезопасность&lt;/li&gt;
  &lt;li&gt;Отсутствие блокировок всей таблицы во время доступа к ней&lt;/li&gt;
  &lt;li&gt;Желательно, чтобы отсутствовали блокировки таблицы при выполнении операции чтения&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В ConcurrentHashMap был введен новый слой абстракции, называемый сегментами (Segment). Другими слова Segment - это массив хэш-таблиц (концептуально).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://howtodoinjava.com/wp-content/uploads/ConcurrentHashMap1.jpg?cb170b&quot; alt=&quot;enter image description here&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ConcurrentHashMap делиться на сегменты (по умолчанию 16) при инициализации. Именно сегменты нам позволяют использовать нашу Map-у, множеством потоков без блокирования всего объекта. Другими словами, когда один поток занят пятым сегментом, 15 сегментов свободны для взаимодействия с другими потоками. То есть, происходит блокировка только одного сегмента, а не целого объекта.&lt;/p&gt;

&lt;p&gt;Ниже приведена таблица тестов HashTable и ConcurrentHashMap в многопоточной среде.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Threads&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;ConcurrentHashMap&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Hashtable&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1.00&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1.03&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2.59&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;32.40&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;5.58&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;78.23&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;8&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;13.21&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;163.48&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;16&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;27.58&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;341.21&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;32&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;57.27&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;778.41&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/java/library/j-jtp07233/index.html&quot;&gt;источник&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;В этой статье я только поверхностно коснулся ConcurrentHashMap и synchronized Map.
Для более глубокого понимания прошу вас в мир документации Java - &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/&quot;&gt;http://docs.oracle.com/javase/7/docs/api/&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 17 Feb 2014 12:00:00 +0200</pubDate>
        <link>http://sannystark.github.io/concurrency/java/2014/02/17/concurrncy-java-sync.html</link>
        <guid isPermaLink="true">http://sannystark.github.io/concurrency/java/2014/02/17/concurrncy-java-sync.html</guid>
        
        
        <category>concurrency</category>
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>Log4j 2. Обзор</title>
        <description>&lt;p&gt;Логированием пользуются почти все средние(большие) приложения, для сбора статистики, выявления ошибок и т.д. Оно играет одну из важных ролей, так как необходимо создать правильный формат сообщения, место хранения этого сообщения, и самое главное, что бы механизм логирования не влиял на производительность системы в целом.
&lt;!--more--&gt;
Так что же нового появилось во второй версии :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;В Log4j версии 1.x была проблема потери событий(сообщений) во время runtime пере-конфигурации. В Log4j эта проблема решена.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Log4j 2.x имеет асинхронный механизм логирования следующего поколения, построенный на библиотеке LMAX Disruptor. Это позволяет в 10 раз увеличить пропускную способность в многопоточной среде.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Log4j 2 использует систему плагинов, которые позволяет легко расширять фрэймворк новыми  Appenders, Filters, Layouts, Lookups, и Pattern Converters не требующих никаких изменений самого Log4j.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Появилась поддержка Message объектов. Пользователи могут легко создавать собственные сообщения, с кастомными слоями фильтрами и т.д.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Проявился большой набор фильтров для Appender-ов для пред-обработки и пост-обработки сообщений.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Layouts в Log4j 1.x и Logback возвращают  String. В новой версии Layout всегда возвращает мисcив байтов, что даёт возможность использовать эти байты в Appenders а не только для записи в OutputStream.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Syslog Appender поддерживает как TCP так и UDP.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Log4j 2 использует преимущества concurrency(java 5). Это решило ряд проблем с предыдущей версией, но некоторые классы пока остались   синхронизированными(synchronization).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Появилась поддержка JMX для мониторинга и конфигурации.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Так же появилась возможность сохранять логи в NoSQL хранилищах, таких как CouchDB и MongoDB.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Для тех кто переходит со старой версии на вторую следует помнить :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Поддержка java 6 и выше.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;XML конфигурация была изменена и стала несовместимой с Log4j 1.x.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Конфигурация с помощью properties уже не поддерживается.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Появилась поддержка JSON или YAML конфигурирования.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Log4j 2 несовместима  с Log4j 1.x.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Log4j 2 обещает много новых фишек и плюшек, осталось только попробовать их в действии :)&lt;/p&gt;

&lt;p&gt;Для более подробной информации прошу на сайт Log4j 2.&lt;/p&gt;
</description>
        <pubDate>Sun, 12 Jan 2014 12:00:00 +0200</pubDate>
        <link>http://sannystark.github.io/log4j/2014/01/12/log4j-2.html</link>
        <guid isPermaLink="true">http://sannystark.github.io/log4j/2014/01/12/log4j-2.html</guid>
        
        
        <category>log4j</category>
        
      </item>
    
  </channel>
</rss>
