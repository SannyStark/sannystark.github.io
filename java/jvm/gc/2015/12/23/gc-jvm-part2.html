<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Алгоритм работы Serial GC, Parrallel GC. Часть 1.</title>
  <meta name="description" content="Рассмотрим двух ветеранов по сборке мусора в HotSpot JVM и их особенности.">

	<link rel="shortcut icon" href="/favicon.ico?" type="image/x-icon">
	<link rel="icon" href="/favicon.ico" type="image/x-icon">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://sannystark.github.io/java/jvm/gc/2015/12/23/gc-jvm-part2.html">
  <link rel="alternate" type="application/rss+xml" title="Блог умелого разработчика" href="http://sannystark.github.io/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Блог умелого разработчика</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">Обо мне</a>
          
        
          
          <a class="page-link" href="/archive/">Архив</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Алгоритм работы Serial GC, Parrallel GC. Часть 1.</h1>
    <p class="post-meta"><time datetime="2015-12-23T18:00:00+02:00" itemprop="datePublished">Dec 23, 2015</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Рассмотрим двух ветеранов по сборке мусора в HotSpot JVM и их особенности.
<!--more--></p>

<h2 id="gc----">Как GC очищает память от мусора</h2>
<p>Есть несколько алгоритмов очищения мусора, из основных можно выделить два :</p>

<ul>
  <li>Copying collectors</li>
  <li>Mark-sweep-compact</li>
</ul>

<h4 id="copying-collectors">Copying collectors</h4>

<p>Память делится на два участка : from-space и to-space.</p>

<p>Принцип работы таков :</p>

<ul>
  <li>Создание(allocate) объекта в “from-space” (1,2)</li>
  <li>Когда “from-space” заполнен, запускатеся сборщик мусора (3)</li>
  <li>Приложение приостанавливается (stop-the-world)</li>
  <li>Находятся живые объекты в “from-space” и копируются в “to-space” (4)</li>
  <li>Когда все объекты скопированы в “to-space”, “from-space” полностью очищается (5)</li>
  <li>После “to-space” и “from-space” меняются местами (5)</li>
</ul>

<p><img src="https://www.artima.com/insidejvm/ed2/images/fig9-1.gif" alt="JVM Memory Model" /></p>

<p>Минусы подхода:</p>

<ul>
  <li>From-space и to-space должны быть одинакового размера</li>
  <li>Приложение должно остановиться пока полностью не скопирует живие объекты в новую область памяти</li>
</ul>

<h4 id="mark-sweep-compact">Mark-sweep-compact</h4>

<p>Процесс работы можно описать так:</p>

<ul>
  <li>Создание(allocate) обьекта в памяти (1)</li>
  <li>Запустить GC</li>
  <li>Приложение приостанавливается (stop-the-world)</li>
  <li>Обход дерева для маркировки мертвых обьектов (2)</li>
  <li>Удаление объектов из памяти (3)</li>
  <li>После проиcходит дефрагментация памяти, то есть сжатие(перенесения) живих обьектов в начало (4)</li>
</ul>

<p><img src="http://adamansky.bitbucket.org/slides/gc/img/msc2.png" alt="JVM Memory Model" /></p>

<p>Минусы:</p>

<ul>
  <li>Приложение останавливается пока происходит сборка мусора</li>
  <li>Время работы зависит от размеров памяти и количества объектов</li>
</ul>

<p>Сборщики мусора HotSpot VM используют подход “Generational Garbage Collection”. Такой подход позволяет использовать разные алгоритмы для разных этапов(областей памяти) сборки мусора что добавляет эффективности в его работе.</p>

<p>Как я писал в <a href="/java/jvm/gc/2015/12/23/gc-jvm-begin.html">первой</a> статье, опытным путем было замечено что большинтсво новых объектов быстро становятся мусором, и что колличество связей между выжившими объектоми и вновь родившемися сводятся к минимуму. Была выдвинута слабая гипотеза(weak generational hypothesis) на которую и опирается “Generational Garbage Collection”.</p>

<h2 id="serial-gc">Serial GC</h2>

<p>Serial GC - (последовательный сборщик мусора) это один из первых сборщиков мусора который анонсировала компания Oracle с 1.3 версией Java.
Он медленно но уверенно работал в те далекие времена, когда только начинали сьемки фильма первой части трилогии “Матрица” и апплеты считалось нормой для web-приложений.</p>

<p>Он очень хоршо проявляет себя в работе с небольшим обьемом памяти (100-200 Mb) и в однопроцессорной среде.</p>

<p>Как включить : -XX:+UseSerialGC.</p>

<h4 id="section">Принцип работы</h4>

<p>Принцип сборки мусора основывается на поколениях, и к каждому участку памяти применяется свой алгоритм сборки.</p>

<p>Память разделяется на младшее(Edem, Survivor 0,1) и старшее поколения(Tenured)</p>

<p><img src="/img/serial-gc-1.png" alt="pic" /></p>

<p>Выделяются два этапа сборки мусора :</p>

<ul>
  <li>minor GC</li>
  <li>major GC (полная)</li>
</ul>

<p>Новые обьекты рождаются в Edem.
В определенный момент запускается минорный сборщик мусора который копирует выжевшие обьекты в S-0</p>

<p><img src="/img/serial-gc-2.png" alt="pic" /></p>

<p><img src="/img/serial-gc-3.png" alt="pic" /></p>

<p>После очередной сборки мусора, выжившие обьекты копируются из Edem и S-0 в S-1, соотвественно S-0 становится доступен для выживших обьектов.</p>

<p><img src="/img/serial-gc-4.png" alt="pic" /></p>

<p>Другими словами в минорной сборке мусора работает алгоритм “Copying collectors”.</p>

<p>Так же сборщик мусора следит за тем, сколько цыклов сборки мусора прожил обьект, для того что бы он стал достаточно стар, что бы попасть в Tenured.</p>

<p><img src="/img/serial-gc-5.png" alt="pic" /></p>

<p>После того как Tenured заполнился до определенной критической точки, на ринг выходит major GC, который стирает грань между поколениями(если быть точным то работает с двумя поколениями) и чистит всю память используя алгоритм “Mark-sweep-compact” для старого поколоения и “Copying collectors” для молодого.</p>

<p><img src="/img/serial-gc-6.png" alt="pic" /></p>

<h4 id="section-1">Плюсы и минусы</h4>

<p>Это однопоточный сборщик мусора, который очень любит stop-the-world(STW) моменты. И работает он с небольшим обьемом памяти, так как при увеличении (памяти), STW паузы будут более заметны. Можно сделать вывод что он не прихотлив к ресурсам и спокойно себе пашет в полях операционной среды. Если у вас слабенькая(старенькая) машинка, и не критичны STW паузы, то этот сборщик мусора будет вам очень кстати.</p>

<h4 id="section-2">Настройка</h4>

<p>Единственное с чем можно поиграться в настройках так это с регулировкой обьемов поколений и значением процента заполнения поколений, когда будет срабатывать GC.</p>

<ul>
  <li>Xms и Xmx можно настроить начальный и максимально допустимый размер кучи.</li>
  <li>-XX:MinHeapFreeRatio=? и -XX:MaxHeapFreeRatio=? задают минимальную и максимальную долю свободного места в каждом поколении, при достижении которой размер поколения будет автоматически увеличен или уменьшен соответственно.</li>
  <li>-XX:NewRatio=? отношение размера старшего поколения к суммарному размеру регионов младшего поколения</li>
  <li>-XX:-UseGCOverheadLimit - порог активности сборщика мусора при котором он будет срабатывать</li>
</ul>

<h2 id="parralell-gc">Parralell GC</h2>
<p>Parallel GC (параллельный сборщик) - перенимает идеи Serial GC добавляя в них параллелизм и немного интеллекта. JVM  может автоматически задействовать его если на вашем компьютере несколько ядер.</p>

<p>Как включить : -XX:+UseParallelGC.</p>

<h4 id="section-3">Принцип работы</h4>

<p>При включении параллельного сборщика мусора используются те же самы подходы что и в GC, та же разбивка памяти на Edem, S-0, S-1, Tunered, те же алгоритмы сборки minor cycle и major cycle, но во первых сборка мусора происходит в парралельном режиме, во вторых, добавляется “инетеллектуальность” для оптимизации производительности о которой мы поговорим ниже.</p>

<p>Для параллельной обработки обьектов, дейсвует немного изменнный механизм переноса. Так например каждый поток GC получает свой участок памяти куда он будет копировать выжившие обькты что бы не мешать другим потокам. Это дает ускорение, но немного дефрагментирует память.</p>

<p><img src="/img/parallel-gc-1.png" alt="pic" /></p>

<p>Интеллектуальной составляющей как раз является то, что производительность сборки мусора(так и самого приложения) можно настраивать так, что бы она удовлетворяла ваши потребности. Вы можете указать устраивающие вас параметры производительности — максимальное время сборки и/или пропускную способность — и сборщик будет изо всех сил стараться не превышать заданные пороги. Для этого он будет использовать статистику уже прошедших сборок мусора и исходя из нее планировать параметры дальнейших сборок: варьировать размеры поколений, менять пропорции регионов.</p>

<p>Но это не означет, что GC запрещает нам корректировать размеры поколений самостоятельно, но не рекомендуется это делать одновременно (что бы портить внутреннюю статистику).</p>

<h4 id="section-4">Плюсы и минусы</h4>

<p>Время STW пауз значительно ниже, так как сборка происходит в параллельном режиме, да и плюс “интеллектуальность” помогает еще больше уменьшить эти паузы (предварительно разогрев JVM). Из минусов можно сказать что появляется фрагментация памяти, но вряд ли она будет значительной, так как сборщиком мусора использует относительно небольшое колличество потоков.</p>

<h4 id="section-5">Настройка</h4>

<p>Размер областей поколений настраивается так же как и Serail GC, поэтому здесь мы рассмотрим настройку производительности для нашего “умного” сборщика мусора.</p>

<ul>
  <li>-XX:ParallelGCThreads=? - колличество потоков для сборки мусора</li>
  <li>-XX:-UseParallelOldGC. - так же можно исключить работу парралельного сборщика мусора в старшем поколении, задейсвовав однопоточный</li>
  <li>-XX:MaxGCPauseMillis - устанавливает ограничение на максимальное время приостановки программы для сборки мусора</li>
  <li>GCTimeRatio - можно указать желаемый порог пропускной способности (отношения времени работы программы ко времени сборки мусора)</li>
  <li>-XX:YoungGenerationSizeIncrement=? и -XX:TenuredGenerationSizeIncrement=? устанавливают, на сколько процентов следует при необходимости увеличивать младшее и старшее поколение соотвественно. По умолчанию оба этих параметра равны 20.</li>
</ul>

<p>В целом эти два сборщика мусора являются основопологающими и подходят для большинсва приложений. Они просты, понятны, без лишних овехедов и скрытых накладных ресурсов.</p>

<p>В следующей статье мы коснемся более изерщренных подходов и механизмов в сборке мусора, такикх как CMS GC и G1.</p>

  </div>
  
	<div id="disqus_thread"></div>
	    <script type="text/javascript">
	        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
	        var disqus_shortname = 'sannystark'; // required: replace example with your forum shortname
	        // var disqus_developer = 1; // Comment out when the site is live
	        var disqus_identifier = "/java/jvm/gc/2015/12/23/gc-jvm-part2.html";
	        //var disqus_developer = 1;

	        /* * * DON'T EDIT BELOW THIS LINE * * */
	        (function() {
	            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	        })();
	    </script>
	    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
	    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
	

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Блог умелого разработчика</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Блог умелого разработчика</li>
          <li><a href="mailto:stasenfox@gmail.com">stasenfox@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/sannystark"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">sannystark</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/stasenfox"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">stasenfox</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Блог о програмировании, алгоритмах, уязвимостях, безисходности и черной материи
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
